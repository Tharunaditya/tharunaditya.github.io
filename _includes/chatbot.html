<!-- Cyberpunk Glass Chatbot Widget -->
<!-- Library for Markdown Parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<div class="chat-widget-container">
    <!-- Floating Action Button -->
    <button id="chat-toggle-btn" class="chat-toggle-btn" aria-label="Open AI Assistant">
        <i class="fas fa-robot"></i>
        <div class="chat-pulse-ring"></div>
    </button>

    <!-- Chat Interface -->
    <div id="chat-interface" class="chat-interface hidden">
        <div class="chat-header">
            <div class="chat-header-info">
                <i class="fas fa-shield-alt"></i>
                <div>
                    <h3 class="chat-title">SecBot v1.0</h3>
                    <span class="chat-status">‚óè Online</span>
                </div>
            </div>
            <div class="chat-controls">
                <div class="size-controls">
                    <button class="size-dot dot-sm active" onclick="setChatSize(1)" aria-label="Small Size"></button>
                    <button class="size-dot dot-md" onclick="setChatSize(2)" aria-label="Medium Size"></button>
                    <button class="size-dot dot-lg" onclick="setChatSize(3)" aria-label="Large Size"></button>
                </div>
                <button id="chat-close-btn" class="chat-close-btn">&times;</button>
            </div>
        </div>

        <div id="chat-messages" class="chat-messages">
            <!-- Initial Greeting -->
            <div class="message bot-message">
                <div class="message-content">
                    <p>Greetings. I am <strong>SecBot</strong>.</p>
                    <p>I have indexed all <strong>{{ site.posts.size }}</strong> security articles on this blog. Ask me about Microarchitecture, AI Injection, or Buffer Overflows.</p>
                </div>
                <span class="message-time">Now</span>
            </div>
        </div>

        <div class="chat-input-area">
            <form id="chat-form" onsubmit="handleChatSubmit(event)">
                <input type="text" id="chat-input" placeholder="Ask about cybersecurity..." autocomplete="off">
                <button type="submit" class="chat-send-btn">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </form>
        </div>
    </div>
</div>

<script>
    // Capture Page Context for the Bot
    const pageContext = {
        title: "{{ page.title | default: site.title | escape }}",
        {% if page.layout == 'post' %}
        isArticle: true,
        // Detailed content ONLY for actual articles
        content: "{{ page.content | strip_html | strip_newlines | escape | truncate: 2500 }}"
        {% else %}
        isArticle: false,
        // General description for other pages (Home, Blog Index, etc.)
        content: "User is currently browsing the page: {{ page.title | default: 'Home' }}. Description: {{ page.description | default: site.description | escape }}"
        {% endif %}
    };

    const chatToggle = document.getElementById('chat-toggle-btn');
    const chatInterface = document.getElementById('chat-interface');
    const chatClose = document.getElementById('chat-close-btn');
    const chatMessages = document.getElementById('chat-messages');

    // Resizing Logic
    function setChatSize(size) {
        // Remove all size classes
        chatInterface.classList.remove('size-1x', 'size-2x', 'size-3x');
        
        // Add new size class
        chatInterface.classList.add(`size-${size}x`);
        
        // Update active dot
        document.querySelectorAll('.size-dot').forEach(dot => dot.classList.remove('active'));
        const dotIndex = size === 1 ? 0 : size === 2 ? 1 : 2; // Map 1->sm, 2->md, 3->lg
        
        // Simple mapping based on order in DOM
        const dots = document.querySelectorAll('.size-dot');
        if(dots[size-1]) dots[size-1].classList.add('active');
    }

    // Toggle Chat
    chatToggle.addEventListener('click', () => {
        chatInterface.classList.toggle('hidden');
        chatInterface.classList.toggle('visible');
        if (chatInterface.classList.contains('visible')) {
            document.getElementById('chat-input').focus();
        }
    });

    chatClose.addEventListener('click', () => {
        chatInterface.classList.remove('visible');
        chatInterface.classList.add('hidden');
    });

    // Real Chat Functionality
    async function handleChatSubmit(e) {
        e.preventDefault();
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        
        if (!text) return;

        // Add User Message
        appendMessage('user', text);
        input.value = '';

        // Show Typing Indicator
        showTypingIndicator();

        try {
            // Call the Cloudflare Worker
            const response = await fetch('https://secbot-proxy.anuganti9.workers.dev', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    message: text,
                    context: pageContext // Send the current article info
                })
            });

            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();
            
            // Expected OpenAI-compatible format: data.choices[0].message.content
            const botReply = data.choices && data.choices[0] && data.choices[0].message 
                ? data.choices[0].message.content 
                : "Security breach detected in communication protocol. (API Error)";

            removeTypingIndicator();
            // Parse Markdown to HTML
            const htmlReply = marked.parse(botReply);
            appendMessage('bot', htmlReply);

        } catch (error) {
            console.error('Error:', error);
            removeTypingIndicator();
            appendMessage('bot', "Connection failed. The secure line is down.");
        }
    }

    function appendMessage(sender, htmlContent) {
        const div = document.createElement('div');
        div.className = `message ${sender}-message`;
        // Ensure user input is escaped if it's not already, but usually text input is safe to display as text. 
        // For the bot (Markdown), we trust the HTML. For user, we might want to be careful if we processed it as markdown too.
        // For consistency, let's treat user input as text and bot input as HTML.
        
        let finalContent = htmlContent;
        if (sender === 'user') {
            // Escape user input to prevent XSS if they type HTML
            const temp = document.createElement('div');
            temp.textContent = htmlContent;
            finalContent = `<p>${temp.innerHTML}</p>`;
        }

        div.innerHTML = `
            <div class="message-content">${finalContent}</div>
            <span class="message-time">Just now</span>
        `;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function showTypingIndicator() {
        const div = document.createElement('div');
        div.id = 'typing-indicator';
        div.className = 'message bot-message typing';
        div.innerHTML = `
            <div class="message-content">
                <div class="typing-dots">
                    <span></span><span></span><span></span>
                </div>
            </div>
        `;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function removeTypingIndicator() {
        const el = document.getElementById('typing-indicator');
        if (el) el.remove();
    }
</script>